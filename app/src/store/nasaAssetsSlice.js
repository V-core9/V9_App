import { createAsyncThunk, createSlice, } from '@reduxjs/toolkit';

const initialState = {
  collection: {},
  status: 'idle',
  search: {
    q: '',
    yearStart: 1,
    yearEnd: (new Date()).getFullYear(),
    title: '',
    description: '',
    location: '',
    page: 1,
    media_type: []
  },
};


export const startSearch = createAsyncThunk(
  'nasaAssets/startSearch',
  async (data) => {

    const { q, yearStart, yearEnd, page, media_type, title, description, location } = data;

    let medType = ``;
    if (media_type.length > 0) {
      medType = `&media_type=${media_type[0]}`;
      if (media_type[1] !== undefined) medType += `,${media_type[1]}`;
      if (media_type[2] !== undefined) medType += `,${media_type[2]}`;
    }

    const yStart = (yearStart == null) ? `` : `&year_start=${yearStart}`;
    const yEnd = (yearEnd == null) ? `` : `&year_end=${yearEnd}`;

    const reqTitle = (title === '') ? `` : `&title=${title}`;
    const reqDescription = (description === '') ? `` : `&title=${description}`;
    const reqLocation = (location === '') ? `` : `&location=${location}`;

    const resp = await fetch(`https://images-api.nasa.gov/search?q=${q}${medType}${yStart}${yEnd}${reqTitle}${reqDescription}${reqLocation}&page=${page}`, { method: 'GET', redirect: 'follow' });
    console.log(resp.body);
    return resp.text();
  }
);


export const nasaAssetsSlice = createSlice({
  name: 'nasaAssets',
  initialState,
  // The `reducers` field lets us define reducers and generate associated actions
  reducers: {
    setSearchQ: (state, action) => {
      state.search.q = action.payload;
    },
    setYearEnd: (state, action) => {
      const value = Number(action.payload);
      if (Number.isInteger(value) && value <= (new Date()).getFullYear() && value >= state.search.yearStart) state.search.yearEnd = value;
    },
    resetYearEnd: (state) => {
      state.search.yearEnd = (new Date()).getFullYear();
    },
    setYearStart: (state, action) => {
      const value = Number(action.payload);
      if (Number.isInteger(value) && value > 0 && value <= state.search.yearEnd) state.search.yearStart = value;
    },
    resetYearStart: (state) => {
      state.search.yearStart = 1;
    },
    nextPage: (state) => {
      const total = state.collection.metadata.total_hits;
      if (((total / 100) - state.search.page) > 1) state.search.page += 1;
    },
    prevPage: (state) => {
      if (state.search.page > 1) state.search.page -= 1;
    },
    resetPage: (state, action) => {
      state.search.page = 1;
    },
    setPage: (state, action) => {
      state.search.page = parseInt(action.payload);
    },
    toggleImageMediaType: (state) => {
      const position = state.search.media_type.indexOf('image');
      if (position === -1) {
        state.search.media_type.push('image');
      } else {
        state.search.media_type.splice(position, 1);
      }
    },
    toggleVideoMediaType: (state) => {
      const position = state.search.media_type.indexOf('video');
      if (position === -1) {
        state.search.media_type.push('video');
      } else {
        state.search.media_type.splice(position, 1);
      }
    },
    toggleAudioMediaType: (state) => {
      const position = state.search.media_type.indexOf('audio');
      if (position === -1) {
        state.search.media_type.push('audio');
      } else {
        state.search.media_type.splice(position, 1);
      }
    },
    setTitle: (state, action) => {
      try {
        let val = String(action.payload);
        if (typeof val === 'string') state.search.title = val;
      } catch (e) {
        console.log(e);
      }
    },
    setDescription: (state, action) => {
      try {
        let val = String(action.payload);
        if (typeof val === 'string') state.search.description = val;
      } catch (e) {
        console.log(e);
      }
    },
    setLocation: (state, action) => {
      try {
        let val = String(action.payload);
        if (typeof val === 'string') state.search.location = val;
      } catch (e) {
        console.log(e);
      }
    }
  },
  // The `extraReducers` field lets the slice handle actions defined elsewhere,
  // including actions generated by createAsyncThunk or in other slices.
  extraReducers: (builder) => {

    builder
      .addCase(startSearch.pending, (state) => {
        state.status = 'loading';
      })
      .addCase(startSearch.rejected, (state) => {
        state.status = 'error';
      })
      .addCase(startSearch.fulfilled, (state, action) => {
        state.status = 'idle';
        const rez = JSON.parse(action.payload);
        console.log('JSON.parse(action.payload)', rez);
        if (rez.collection) {
          state.collection = rez.collection;
        } else {
          state.collection = {};
        }
      });

  },
});

export const { setSearchQ, setYearEnd, setYearStart, resetYearStart, resetYearEnd, toggleImageMediaType, toggleVideoMediaType, toggleAudioMediaType, setTitle, setDescription, setLocation } = nasaAssetsSlice.actions;

export const selectSearch = (state) => state.nasaAssets.search;

export const goToPage = (val) => (dispatch, getState) => {
  dispatch(nasaAssetsSlice.actions.setPage(val));
  dispatch(startSearch(selectSearch(getState())));
};

export const goToNextPage = () => (dispatch, getState) => {
  dispatch(nasaAssetsSlice.actions.nextPage());
  dispatch(startSearch(selectSearch(getState())));
};

export const goToPrevPage = () => (dispatch, getState) => {
  dispatch(nasaAssetsSlice.actions.prevPage());
  dispatch(startSearch(selectSearch(getState())));
};

export const startNewSearch = () => (dispatch, getState) => {
  dispatch(nasaAssetsSlice.actions.resetPage());
  dispatch(startSearch(selectSearch(getState())));
};

export default nasaAssetsSlice.reducer;
